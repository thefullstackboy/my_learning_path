{"version":3,"file":"d56fb69a.js","sources":["../src/codegen.js","../src/parser.js","../src/babel/transform.js"],"sourcesContent":["const _state = 'state';\nconst _node = 'node';\nconst _match = 'x';\n\nfunction js(/* arguments */) {\n  let body = arguments[0][0];\n  for (let i = 1; i < arguments.length; i++)\n    body = body + arguments[i] + arguments[0][i];\n  return body.trim();\n}\n\nconst copy = (prev) => {\n  const next = {};\n  for (const key in prev) next[key] = prev[key];\n  return next;\n};\n\nconst assignIndex = (depth) => js`\n  var y${depth} = ${_state}.y,\n      x${depth} = ${_state}.x;\n`;\n\nconst restoreIndex = (depth) => js`\n  ${_state}.y = y${depth};\n  ${_state}.x = x${depth};\n`;\n\nconst astExpression = (ast, depth, opts) => {\n  const capture = !!opts.capture && !ast.capture;\n  const restoreLength =\n    (opts.length && opts.abort && js`${_node}.length = ln${opts.length};`) ||\n    '';\n  const condition = `(${_match} = ${ast.expression.id}(${_state})) ${\n    capture ? '!=' : '=='\n  } null`;\n  return js`\n    if (${condition}) ${\n    capture\n      ? js`{\n      ${_node}.push(${_match});\n    } else `\n      : ''\n  }{\n      ${restoreIndex(opts.index)}\n      ${restoreLength}\n      ${opts.abort}\n    }\n  `;\n};\n\nconst astGroup = (ast, depth, opts) => {\n  const capture = !!opts.capture && !ast.capture;\n\n  opts = copy(opts);\n  opts.capture = capture;\n\n  if (!opts.length && capture) {\n    opts.length = depth;\n    return js`\n      ${js`var ln${depth} = ${_node}.length;`}\n      ${astSequence(ast.sequence, depth + 1, opts)}\n    `;\n  }\n\n  return astSequence(ast.sequence, depth + 1, opts);\n};\n\nconst astChild = (ast, depth, opts) =>\n  ast.expression ? astExpression(ast, depth, opts) : astGroup(ast, depth, opts);\n\nconst astQuantifier = (ast, depth, opts) => {\n  const { index, abort } = opts;\n  const invert = `inv_${depth}`;\n  const group = `group_${depth}`;\n\n  opts = copy(opts);\n  if (ast.capture === '!') {\n    opts.index = depth;\n    opts.abort = js`break ${invert}`;\n  }\n\n  let child;\n  if (ast.quantifier === '+') {\n    const starAst = copy(ast);\n    starAst.quantifier = '*';\n    child = js`\n      ${astChild(ast, depth, opts)}\n      ${astQuantifier(starAst, depth, opts)}\n    `;\n  } else if (ast.quantifier === '*') {\n    opts.length = 0;\n    opts.index = depth;\n    opts.abort = js`break ${group};`;\n\n    child = js`\n      ${group}: for (;;) {\n        ${assignIndex(depth)}\n        ${astChild(ast, depth, opts)}\n      }\n    `;\n  } else if (ast.quantifier === '?' && ast.expression) {\n    opts.index = depth;\n    opts.abort = '';\n\n    child = js`\n      ${assignIndex(depth)}\n      ${astChild(ast, depth, opts)}\n    `;\n  } else if (ast.quantifier === '?') {\n    opts.index = depth;\n    opts.abort = js`break ${group}`;\n\n    child = js`\n      ${group}: {\n        ${assignIndex(depth)}\n        ${astChild(ast, depth, opts)}\n      }\n    `;\n  } else {\n    child = astChild(ast, depth, opts);\n  }\n\n  if (ast.capture === '!') {\n    return js`\n      ${invert}: {\n        ${assignIndex(depth)}\n        ${child}\n        ${restoreIndex(index)}\n        ${abort}\n      }\n    `;\n  } else if (ast.capture === '=') {\n    return js`\n      ${assignIndex(depth)}\n      ${child}\n      ${restoreIndex(depth)}\n    `;\n  } else {\n    return child;\n  }\n};\n\nconst astSequence = (ast, depth, opts) => {\n  const alternation = ast.alternation ? `alt_${depth}` : '';\n\n  let body = '';\n  for (; ast; ast = ast.alternation) {\n    const block = `block_${depth}`;\n\n    let childOpts = opts;\n    if (ast.alternation) {\n      childOpts = copy(opts);\n      childOpts.index = depth;\n      childOpts.abort = js`break ${block};`;\n    }\n\n    let sequence = '';\n    for (let i = 0; i < ast.length; i++)\n      sequence += astQuantifier(ast[i], depth, childOpts);\n\n    if (!ast.alternation) {\n      body += sequence;\n    } else {\n      body += js`\n        ${block}: {\n          ${assignIndex(depth)}\n          ${sequence}\n          break ${alternation};\n        }\n      `;\n    }\n  }\n\n  if (!alternation) return body;\n\n  return js`\n    ${alternation}: {\n      ${body}\n    }\n  `;\n};\n\nconst astRoot = (ast, name, transform) => {\n  return js`\n    (function (${_state}) {\n      ${assignIndex(1)}\n      var ${_node} = [];\n      var ${_match};\n\n      ${astSequence(ast, 2, {\n        index: 1,\n        length: 0,\n        abort: js`return;`,\n        capture: true,\n      })}\n\n      if (${name}) ${_node}.tag = ${name};\n      return ${transform ? js`(${transform})(${_node})` : _node};\n    })\n  `;\n};\n\nexport { astRoot };\n","const syntaxError = (char) => {\n  throw new SyntaxError('Unexpected token \"' + char + '\"');\n};\n\nexport const parse = (quasis, expressions) => {\n  let quasiIndex = 0;\n  let stackIndex = 0;\n\n  const sequenceStack = [];\n  const rootSequence = [];\n\n  let currentGroup = null;\n  let lastMatch;\n  let currentSequence = rootSequence;\n  let capture;\n\n  for (\n    let quasiIndex = 0, stackIndex = 0;\n    stackIndex < quasis.length + expressions.length;\n    stackIndex++\n  ) {\n    if (stackIndex % 2 !== 0) {\n      const expression = expressions[stackIndex++ >> 1];\n      currentSequence.push({ expression, capture });\n      capture = undefined;\n    }\n\n    const quasi = quasis[stackIndex >> 1];\n    for (quasiIndex = 0; quasiIndex < quasi.length; ) {\n      const char = quasi[quasiIndex++];\n      if (char === ' ' || char === '\\t' || char === '\\r' || char === '\\n') {\n      } else if (char === '|' && currentSequence.length) {\n        currentSequence = currentSequence.alternation = [];\n      } else if (char === ')' && currentSequence.length) {\n        currentGroup = null;\n        currentSequence = sequenceStack.pop();\n        if (!currentSequence) syntaxError(char);\n      } else if (char === '(') {\n        sequenceStack.push(currentSequence);\n        currentSequence.push((currentGroup = { sequence: [], capture }));\n        currentSequence = currentGroup.sequence;\n        capture = undefined;\n      } else if (char === ':' || char === '=' || char === '!') {\n        capture = char;\n        const nextChar = quasi[quasiIndex];\n        if (quasi[quasiIndex] && quasi[quasiIndex] !== '(') syntaxError(char);\n      } else if (char === '?' && !currentSequence.length && currentGroup) {\n        capture = quasi[quasiIndex++];\n        if (capture === ':' || capture === '=' || capture === '!') {\n          currentGroup.capture = capture;\n          capture = undefined;\n        } else {\n          syntaxError(char);\n        }\n      } else if (\n        (char === '?' || char === '+' || char === '*') &&\n        (lastMatch = currentSequence[currentSequence.length - 1])\n      ) {\n        lastMatch.quantifier = char;\n      } else {\n        syntaxError(char);\n      }\n    }\n  }\n\n  return rootSequence;\n};\n","import { astRoot } from '../codegen';\nimport { parse } from '../parser';\n\nexport function makeHelpers({ types: t, template }) {\n  const regexPatternsRe = /^[()\\[\\]|.+?*]|[^\\\\][()\\[\\]|.+?*$^]|\\\\[wdsWDS]/;\n  const importSourceRe = /reghex$|^reghex\\/macro/;\n  const importName = 'reghex';\n\n  let _hasUpdatedImport = false;\n  let _matchId = t.identifier('match');\n  let _patternId = t.identifier('__pattern');\n\n  const _hoistedExpressions = new Map();\n\n  return {\n    /** Adds the reghex import declaration to the Program scope */\n    updateImport(path) {\n      if (_hasUpdatedImport) return;\n      if (!importSourceRe.test(path.node.source.value)) return;\n      _hasUpdatedImport = true;\n\n      if (path.node.source.value !== importName) {\n        path.node.source = t.stringLiteral(importName);\n      }\n\n      _patternId = path.scope.generateUidIdentifier('_pattern');\n      path.node.specifiers.push(\n        t.importSpecifier(_patternId, t.identifier('__pattern'))\n      );\n\n      const tagImport = path.node.specifiers.find((node) => {\n        return t.isImportSpecifier(node) && node.imported.name === 'match';\n      });\n\n      if (!tagImport) {\n        path.node.specifiers.push(\n          t.importSpecifier(\n            (_matchId = path.scope.generateUidIdentifier('match')),\n            t.identifier('match')\n          )\n        );\n      } else {\n        _matchId = tagImport.imported;\n      }\n    },\n\n    /** Determines whether the given tagged template expression is a reghex match */\n    isMatch(path) {\n      if (\n        t.isTaggedTemplateExpression(path.node) &&\n        t.isCallExpression(path.node.tag) &&\n        t.isIdentifier(path.node.tag.callee) &&\n        path.scope.hasBinding(path.node.tag.callee.name)\n      ) {\n        if (t.isVariableDeclarator(path.parentPath))\n          path.parentPath._isMatch = true;\n        return true;\n      }\n\n      return (\n        t.isVariableDeclarator(path.parentPath) && path.parentPath._isMatch\n      );\n    },\n\n    /** Given a reghex match, returns the path to reghex's match import declaration */\n    getMatchImport(path) {\n      t.assertTaggedTemplateExpression(path.node);\n      const binding = path.scope.getBinding(path.node.tag.callee.name);\n\n      if (\n        binding.kind !== 'module' ||\n        !t.isImportDeclaration(binding.path.parent) ||\n        !importSourceRe.test(binding.path.parent.source.value) ||\n        !t.isImportSpecifier(binding.path.node)\n      ) {\n        return null;\n      }\n\n      return binding.path.parentPath;\n    },\n\n    /** Given a match, returns an evaluated name or a best guess */\n    getMatchName(path) {\n      t.assertTaggedTemplateExpression(path.node);\n      const nameArgumentPath = path.get('tag.arguments.0');\n      if (nameArgumentPath) {\n        const { confident, value } = nameArgumentPath.evaluate();\n        if (!confident && t.isIdentifier(nameArgumentPath.node)) {\n          return nameArgumentPath.node.name;\n        } else if (confident && typeof value === 'string') {\n          return value;\n        }\n      }\n\n      return path.scope.generateUidIdentifierBasedOnNode(path.node);\n    },\n\n    /** Given a match, hoists its expressions in front of the match's statement */\n    _prepareExpressions(path) {\n      t.assertTaggedTemplateExpression(path.node);\n\n      const variableDeclarators = [];\n      const matchName = this.getMatchName(path);\n\n      const hoistedExpressions = path.node.quasi.expressions.map(\n        (expression, i) => {\n          if (\n            t.isArrowFunctionExpression(expression) &&\n            t.isIdentifier(expression.body)\n          ) {\n            expression = expression.body;\n          } else if (\n            (t.isFunctionExpression(expression) ||\n              t.isArrowFunctionExpression(expression)) &&\n            t.isBlockStatement(expression.body) &&\n            expression.body.body.length === 1 &&\n            t.isReturnStatement(expression.body.body[0]) &&\n            t.isIdentifier(expression.body.body[0].argument)\n          ) {\n            expression = expression.body.body[0].argument;\n          }\n\n          const isBindingExpression =\n            t.isIdentifier(expression) &&\n            path.scope.hasBinding(expression.name);\n          if (isBindingExpression) {\n            const binding = path.scope.getBinding(expression.name);\n            if (t.isVariableDeclarator(binding.path.node)) {\n              const matchPath = binding.path.get('init');\n              if (this.isMatch(matchPath)) {\n                return expression;\n              } else if (_hoistedExpressions.has(expression.name)) {\n                return t.identifier(_hoistedExpressions.get(expression.name));\n              }\n            }\n          }\n\n          const id = path.scope.generateUidIdentifier(\n            isBindingExpression\n              ? `${expression.name}_expression`\n              : `${matchName}_expression`\n          );\n\n          variableDeclarators.push(\n            t.variableDeclarator(\n              id,\n              t.callExpression(t.identifier(_patternId.name), [expression])\n            )\n          );\n\n          if (t.isIdentifier(expression)) {\n            _hoistedExpressions.set(expression.name, id.name);\n          }\n\n          return id;\n        }\n      );\n\n      if (variableDeclarators.length) {\n        path\n          .getStatementParent()\n          .insertBefore(t.variableDeclaration('var', variableDeclarators));\n      }\n\n      return hoistedExpressions.map((id) => {\n        const binding = path.scope.getBinding(id.name);\n        if (binding && t.isVariableDeclarator(binding.path.node)) {\n          const matchPath = binding.path.get('init');\n          if (this.isMatch(matchPath)) {\n            return { fn: true, id: id.name };\n          }\n        }\n\n        const input = t.isStringLiteral(id)\n          ? JSON.stringify(id.value)\n          : id.name;\n        return { fn: false, id: input };\n      });\n    },\n\n    _prepareTransform(path) {\n      const transformNode = path.node.tag.arguments[1];\n\n      if (!transformNode) return null;\n      if (t.isIdentifier(transformNode)) return transformNode.name;\n\n      const matchName = this.getMatchName(path);\n      const id = path.scope.generateUidIdentifier(`${matchName}_transform`);\n      const declarator = t.variableDeclarator(id, transformNode);\n\n      path\n        .getStatementParent()\n        .insertBefore(t.variableDeclaration('var', [declarator]));\n\n      return id.name;\n    },\n\n    minifyMatch(path) {\n      const quasis = path.node.quasi.quasis.map((x) =>\n        t.stringLiteral(x.value.cooked.replace(/\\s*/g, ''))\n      );\n      const expressions = path.node.quasi.expressions;\n      const transform = this._prepareTransform(path);\n\n      path.replaceWith(\n        t.callExpression(path.node.tag, [\n          t.arrayExpression(quasis),\n          ...expressions,\n        ])\n      );\n    },\n\n    transformMatch(path) {\n      let name = path.node.tag.arguments[0];\n      if (!name) {\n        name = t.nullLiteral();\n      }\n\n      const quasis = path.node.quasi.quasis.map((x) => x.value.cooked);\n\n      const expressions = this._prepareExpressions(path);\n      const transform = this._prepareTransform(path);\n\n      let ast;\n      try {\n        ast = parse(quasis, expressions);\n      } catch (error) {\n        if (error.name !== 'SyntaxError') throw error;\n        throw path.get('quasi').buildCodeFrameError(error.message);\n      }\n\n      const code = astRoot(ast, '%%name%%', transform && '%%transform%%');\n\n      path.replaceWith(\n        template.expression(code)(transform ? { name, transform } : { name })\n      );\n    },\n  };\n}\n"],"names":["const","_state","_node","_match","js","i","arguments","length","copy","next","assignIndex","restoreIndex","depth","astExpression","capture","opts","index","group","abort","ast","child","quantifier","invert","astSequence","childOpts","block","sequence","body","syntaxError","char","parse","currentSequence","expression","quasi","quasis","_ref3","let","makeHelpers","node","name","stringLiteral","value","identifier","_patternId","path","source","importSpecifier","t","parentPath","nameArgumentPath","matchName","hoistedExpressions","getBinding","generateUidIdentifier","variableDeclarators","insertBefore","get","id","transformNode","getMatchName","error","buildCodeFrameError","code","astRoot","exports"],"mappings":"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"}