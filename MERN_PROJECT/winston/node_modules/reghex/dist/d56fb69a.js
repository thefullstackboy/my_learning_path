'use strict';
var _state = "state", _node = "node", _match = "x";
function js() {
  for (var c = arguments, e = arguments[0][0], b = 1; b < arguments.length; b++) {
    e = e + c[b] + c[0][b];
  }
  return e.trim();
}
var copy = function(c) {
  var e = {}, b;
  for (b in c) {
    e[b] = c[b];
  }
  return e;
}, assignIndex = function(c) {
  return " var y" + (c + ("=" + (_state + (".y,x" + (c + ("=" + (_state + ".x;")))))));
}, restoreIndex = function(c) {
  return _state + (".y=y" + (c + (";" + (_state + (".x=x" + (c + ";"))))));
}, astExpression = function(c, e, b) {
  e = !!b.capture && !c.capture;
  var d = b.length && b.abort && _node + (".length=ln" + (b.length + ";")) || "";
  return " if((" + (_match + " = " + c.expression.id + "(" + _state + ")) " + (e ? "!=" : "==") + " null)" + ((e ? "{" + (_node + (".push(" + (_match + ");}else "))) : "") + ("{" + (restoreIndex(b.index) + (d + (b.abort + "}"))))));
}, astGroup = function(c, e, b) {
  var d = !!b.capture && !c.capture;
  b = copy(b);
  b.capture = d;
  return !b.length && d ? (b.length = e, "var ln" + (e + ("=" + (_node + ".length;"))) + (astSequence(c.sequence, e + 1, b) + "")) : astSequence(c.sequence, e + 1, b);
}, astChild = function(c, e, b) {
  return c.expression ? astExpression(c, e, b) : astGroup(c, e, b);
}, astQuantifier = function(c, e, b) {
  var d = b.index, p = b.abort, q = "inv_" + e, h = "group_" + e;
  b = copy(b);
  "!" === c.capture && (b.index = e, b.abort = "break " + (q + ""));
  "+" === c.quantifier ? (h = copy(c), h.quantifier = "*", b = astChild(c, e, b) + (astQuantifier(h, e, b) + "")) : "*" === c.quantifier ? (b.length = 0, b.index = e, b.abort = "break " + (h + ";"), b = h + (":for(;;){" + (assignIndex(e) + (astChild(c, e, b) + "}")))) : "?" === c.quantifier && c.expression ? (b.index = e, b.abort = "", b = assignIndex(e) + (astChild(c, e, b) + "")) : "?" === c.quantifier ? (b.index = e, b.abort = "break " + (h + ""), b = h + (":{" + (assignIndex(e) + (astChild(c, 
  e, b) + "}")))) : b = astChild(c, e, b);
  return "!" === c.capture ? q + (":{" + (assignIndex(e) + (b + (restoreIndex(d) + (p + "}"))))) : "=" === c.capture ? assignIndex(e) + (b + (restoreIndex(e) + "")) : b;
}, astSequence = function(c, e, b) {
  for (var d = c.alternation ? "alt_" + e : "", p = ""; c; c = c.alternation) {
    var q = "block_" + e, h = b;
    c.alternation && (h = copy(b), h.index = e, h.abort = "break " + (q + ";"));
    for (var l = "", m = 0; m < c.length; m++) {
      l += astQuantifier(c[m], e, h);
    }
    p = c.alternation ? p + (q + (":{" + (assignIndex(e) + (l + (" break " + (d + ";}")))))) : p + l;
  }
  return d ? d + (":{" + (p + "}")) : p;
}, astRoot = function(c, e, b) {
  return "(function(" + (_state + ("){" + (assignIndex(1) + (" var " + (_node + ("=[];var " + (_match + (";" + (astSequence(c, 2, {index:1, length:0, abort:"return;", capture:!0}) + (" if(" + (e + (")" + (_node + (".tag=" + (e + (";return " + ((b ? "(" + (b + (")(" + (_node + ")"))) : _node) + ";})")))))))))))))))));
}, syntaxError = function(c) {
  throw new SyntaxError('Unexpected token "' + c + '"');
}, parse = function(c, e) {
  for (var b = [], d = [], p = null, q, h = d, l, m, a = 0; a < c.length + e.length; a++) {
    0 !== a % 2 && (m = e[a++ >> 1], h.push({expression:m, capture:l}), l = void 0);
    var k = c[a >> 1];
    for (m = 0; m < k.length;) {
      var f = k[m++];
      " " !== f && "\t" !== f && "\r" !== f && "\n" !== f && ("|" === f && h.length ? h = h.alternation = [] : ")" === f && h.length ? (p = null, (h = b.pop()) || syntaxError(f)) : "(" === f ? (b.push(h), h.push(p = {sequence:[], capture:l}), h = p.sequence, l = void 0) : ":" === f || "=" === f || "!" === f ? (l = f, k[m] && "(" !== k[m] && syntaxError(f)) : "?" === f && !h.length && p ? (l = k[m++], ":" === l || "=" === l || "!" === l ? (p.capture = l, l = void 0) : syntaxError(f)) : "?" !== f && 
      "+" !== f && "*" !== f || !(q = h[h.length - 1]) ? syntaxError(f) : q.quantifier = f);
    }
  }
  return d;
};
function _ref3(c) {
  return c.value.cooked;
}
function makeHelpers(c) {
  function e(a) {
    return d.isImportSpecifier(a) && "match" === a.imported.name;
  }
  function b(a) {
    return d.stringLiteral(a.value.cooked.replace(/\s*/g, ""));
  }
  var d = c.types, p = c.template, q = /reghex$|^reghex\/macro/, h = !1;
  d.identifier("match");
  var l = d.identifier("__pattern"), m = new Map;
  return {updateImport:function(a) {
    !h && q.test(a.node.source.value) && (h = !0, "reghex" !== a.node.source.value && (a.node.source = d.stringLiteral("reghex")), l = a.scope.generateUidIdentifier("_pattern"), a.node.specifiers.push(d.importSpecifier(l, d.identifier("__pattern"))), a.node.specifiers.find(e) || a.node.specifiers.push(d.importSpecifier(a.scope.generateUidIdentifier("match"), d.identifier("match"))));
  }, isMatch:function(a) {
    return d.isTaggedTemplateExpression(a.node) && d.isCallExpression(a.node.tag) && d.isIdentifier(a.node.tag.callee) && a.scope.hasBinding(a.node.tag.callee.name) ? (d.isVariableDeclarator(a.parentPath) && (a.parentPath._isMatch = !0), !0) : d.isVariableDeclarator(a.parentPath) && a.parentPath._isMatch;
  }, getMatchImport:function(a) {
    d.assertTaggedTemplateExpression(a.node);
    a = a.scope.getBinding(a.node.tag.callee.name);
    return "module" === a.kind && d.isImportDeclaration(a.path.parent) && q.test(a.path.parent.source.value) && d.isImportSpecifier(a.path.node) ? a.path.parentPath : null;
  }, getMatchName:function(a) {
    d.assertTaggedTemplateExpression(a.node);
    var k = a.get("tag.arguments.0");
    if (k) {
      var f = k.evaluate(), r = f.confident;
      f = f.value;
      if (!r && d.isIdentifier(k.node)) {
        return k.node.name;
      }
      if (r && "string" === typeof f) {
        return f;
      }
    }
    return a.scope.generateUidIdentifierBasedOnNode(a.node);
  }, _prepareExpressions:function(a) {
    var k = this;
    d.assertTaggedTemplateExpression(a.node);
    var f = [], r = this.getMatchName(a), t = a.node.quasi.expressions.map(function(g, n) {
      d.isArrowFunctionExpression(g) && d.isIdentifier(g.body) ? g = g.body : (d.isFunctionExpression(g) || d.isArrowFunctionExpression(g)) && d.isBlockStatement(g.body) && 1 === g.body.body.length && d.isReturnStatement(g.body.body[0]) && d.isIdentifier(g.body.body[0].argument) && (g = g.body.body[0].argument);
      if (n = d.isIdentifier(g) && a.scope.hasBinding(g.name)) {
        var u = a.scope.getBinding(g.name);
        if (d.isVariableDeclarator(u.path.node)) {
          u = u.path.get("init");
          if (k.isMatch(u)) {
            return g;
          }
          if (m.has(g.name)) {
            return d.identifier(m.get(g.name));
          }
        }
      }
      n = a.scope.generateUidIdentifier(n ? g.name + "_expression" : r + "_expression");
      f.push(d.variableDeclarator(n, d.callExpression(d.identifier(l.name), [g])));
      d.isIdentifier(g) && m.set(g.name, n.name);
      return n;
    });
    f.length && a.getStatementParent().insertBefore(d.variableDeclaration("var", f));
    return t.map(function(g) {
      var n = a.scope.getBinding(g.name);
      return n && d.isVariableDeclarator(n.path.node) && (n = n.path.get("init"), k.isMatch(n)) ? {fn:!0, id:g.name} : {fn:!1, id:d.isStringLiteral(g) ? JSON.stringify(g.value) : g.name};
    });
  }, _prepareTransform:function(a) {
    var k = a.node.tag.arguments[1];
    if (!k) {
      return null;
    }
    if (d.isIdentifier(k)) {
      return k.name;
    }
    var f = this.getMatchName(a);
    f = a.scope.generateUidIdentifier(f + "_transform");
    k = d.variableDeclarator(f, k);
    a.getStatementParent().insertBefore(d.variableDeclaration("var", [k]));
    return f.name;
  }, minifyMatch:function(a) {
    var k = a.node.quasi.quasis.map(b), f = a.node.quasi.expressions;
    this._prepareTransform(a);
    a.replaceWith(d.callExpression(a.node.tag, [d.arrayExpression(k)].concat(f)));
  }, transformMatch:function(a) {
    var k = a.node.tag.arguments[0];
    k || (k = d.nullLiteral());
    var f = a.node.quasi.quasis.map(_ref3), r = this._prepareExpressions(a), t = this._prepareTransform(a);
    try {
      var g = parse(f, r);
    } catch (n) {
      if ("SyntaxError" !== n.name) {
        throw n;
      }
      throw a.get("quasi").buildCodeFrameError(n.message);
    }
    f = astRoot(g, "%%name%%", t && "%%transform%%");
    a.replaceWith(p.expression(f)(t ? {name:k, transform:t} : {name:k}));
  }};
}
exports.makeHelpers = makeHelpers

//# sourceMappingURL=d56fb69a.js.map
