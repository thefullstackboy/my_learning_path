
function q(a) {
  var b = {}, c;
  for (c in a) {
    b[c] = a[c];
  }
  return b;
}
function r(a) {
  return " var y" + (a + ("=state.y,x" + (a + "=state.x;")));
}
function v(a) {
  return "state.y=y" + (a + (";state.x=x" + (a + ";")));
}
function w(a, b, c) {
  if (a.expression) {
    b = !!c.capture && !a.capture;
    var d = c.length && c.abort && "node.length=ln" + (c.length + ";") || "";
    a = " if((x = " + (a.expression.id + "(state)) " + (b ? "!=" : "==") + " null)" + ((b ? "{node.push(x);}else " : "") + ("{" + (v(c.index) + (d + (c.abort + "}"))))));
  } else {
    d = !!c.capture && !a.capture, c = q(c), c.capture = d, !c.length && d ? (c.length = b, a = "var ln" + (b + "=node.length;") + (x(a.sequence, b + 1, c) + "")) : a = x(a.sequence, b + 1, c);
  }
  return a;
}
function y(a, b, c) {
  var d = c.index, f = c.abort, l = "inv_" + b, g = "group_" + b;
  c = q(c);
  "!" === a.capture && (c.index = b, c.abort = "break " + (l + ""));
  "+" === a.quantifier ? (g = q(a), g.quantifier = "*", c = w(a, b, c) + (y(g, b, c) + "")) : "*" === a.quantifier ? (c.length = 0, c.index = b, c.abort = "break " + (g + ";"), c = g + (":for(;;){" + (r(b) + (w(a, b, c) + "}")))) : "?" === a.quantifier && a.expression ? (c.index = b, c.abort = "", c = r(b) + (w(a, b, c) + "")) : "?" === a.quantifier ? (c.index = b, c.abort = "break " + (g + ""), c = g + (":{" + (r(b) + (w(a, b, c) + "}")))) : c = w(a, b, c);
  return "!" === a.capture ? l + (":{" + (r(b) + (c + (v(d) + (f + "}"))))) : "=" === a.capture ? r(b) + (c + (v(b) + "")) : c;
}
function x(a, b, c) {
  for (var d = a.alternation ? "alt_" + b : "", f = ""; a; a = a.alternation) {
    var l = "block_" + b, g = c;
    a.alternation && (g = q(c), g.index = b, g.abort = "break " + (l + ";"));
    for (var m = "", n = 0; n < a.length; n++) {
      m += y(a[n], b, g);
    }
    f = a.alternation ? f + (l + (":{" + (r(b) + (m + (" break " + (d + ";}")))))) : f + m;
  }
  return d ? d + (":{" + (f + "}")) : f;
}
function z(a) {
  throw new SyntaxError('Unexpected token "' + a + '"');
}
var A = "boolean" === typeof/./g.sticky;
function B(a) {
  return a.length ? a : function(b) {
    return a()(b);
  };
}
function C(a) {
  return function(b) {
    if (b.x < b.quasis.length) {
      for (var c = b.quasis[b.x], d = 0, f = a.length; d < f; d++) {
        if (c.charCodeAt(b.y + d) !== a.charCodeAt(d)) {
          return null;
        }
      }
      b.y += a.length;
      return a;
    }
  };
}
function D(a) {
  a = A ? new RegExp(a.source, "y") : new RegExp(a.source + "|()", "g");
  return function(b) {
    if (b.x < b.quasis.length) {
      var c = b.quasis[b.x];
      a.lastIndex = b.y;
      var d;
      A ? a.test(c) && (d = c.slice(b.y, a.lastIndex)) : (c = a.exec(c), null == c[1] && (d = c[0]));
      b.y = a.lastIndex;
      return d;
    }
  };
}
function E(a) {
  return "function" === typeof a ? B(a) : "string" === typeof a ? C(a) : D(a);
}
function F(a, b) {
  return {id:"_" + b};
}
function G(a, b) {
  return "_" + b;
}

function interpolation(a) {
  return function(b) {
    if (b.x < b.expressions.length && b.y >= b.quasis[b.x].length) {
      b.y = 0;
      var c = b.expressions[b.x++];
      a && c && (c = a(c));
    }
    return c;
  };
};
function match(a, b) {
  return function(c) {
    for (var d = [], f = arguments.length - 1; 0 < f--;) {
      d[f] = arguments[f + 1];
    }
    var l = d.map(F), g = [];
    f = [];
    for (var m = null, n, k = f, h, p, t = 0; t < c.length + l.length; t++) {
      0 !== t % 2 && (p = l[t++ >> 1], k.push({expression:p, capture:h}), h = void 0);
      var u = c[t >> 1];
      for (p = 0; p < u.length;) {
        var e = u[p++];
        " " !== e && "\t" !== e && "\r" !== e && "\n" !== e && ("|" === e && k.length ? k = k.alternation = [] : ")" === e && k.length ? (m = null, (k = g.pop()) || z(e)) : "(" === e ? (g.push(k), k.push(m = {sequence:[], capture:h}), k = m.sequence, h = void 0) : ":" === e || "=" === e || "!" === e ? (h = e, u[p] && "(" !== u[p] && z(e)) : "?" === e && !k.length && m ? (h = u[p++], ":" === h || "=" === h || "!" === h ? (m.capture = h, h = void 0) : z(e)) : "?" !== e && "+" !== e && "*" !== e || 
        !(n = k[k.length - 1]) ? z(e) : n.quantifier = e);
      }
    }
    n = [a, b].concat(d.map(E));
    h = Function;
    d = "_n,_t," + d.map(G).join(",");
    l = b ? "_t" : null;
    f = "(function(state){" + (r(1) + (" var node=[];var x;" + (x(f, 2, {index:1, length:0, abort:"return;", capture:!0}) + (" if(_n)node.tag=_n;return " + ((l ? "(" + (l + ")(node)") : "node") + ";})")))));
    return (new h(d, "return " + f)).apply(void 0, n);
  };
};
function parse(a) {
  return function(b) {
    for (var c = [], d = arguments.length - 1; 0 < d--;) {
      c[d] = arguments[d + 1];
    }
    "string" === typeof b && (b = [b]);
    return a({quasis:b, expressions:c, x:0, y:0});
  };
};export{E as __pattern,interpolation,match,parse}
//# sourceMappingURL=reghex-core.mjs.map
