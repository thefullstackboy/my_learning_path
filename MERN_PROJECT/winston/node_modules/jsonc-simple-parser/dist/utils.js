"use strict";
/* IMPORT */
Object.defineProperty(exports, "__esModule", { value: true });
const reghex_1 = require("reghex");
/* UTILS */
const Utils = {
    /* VARIABLES */
    tokenDelimiterTypes: new Set(['ArrayOpen', 'ArrayClose', 'ObjectOpen', 'ObjectClose']),
    tokenIgnoredTypes: new Set(['Newline', 'Whitespace', 'CommentLine', 'CommentBlock', 'Comma', 'CommaTrailing', 'Colon']),
    tokenLiteralTypes: new Set(['Null', 'True', 'False', 'Number', 'String', 'Array', 'Object']),
    /* API */
    isEven: (number) => {
        return !(number % 2);
    },
    isOdd: (number) => {
        return !Utils.isEven(number);
    },
    isString: (value) => {
        return typeof value === 'string';
    },
    isToken: (value) => {
        return !Utils.isString(value);
    },
    isTokenDelimiter: (token) => {
        return Utils.tokenDelimiterTypes.has(token.type);
    },
    isTokenIgnored: (token) => {
        return Utils.tokenIgnoredTypes.has(token.type);
    },
    isTokenLiteral: (token) => {
        return Utils.tokenLiteralTypes.has(token.type);
    },
    tokens2matchers: (tokens) => {
        const cache = new Map();
        return Object.keys(tokens).reduce((acc, type) => {
            const transformer = tokens[type];
            const matcher = transformer.unwrapped ? transformer : cache.get(transformer) || (0, reghex_1.match)(type, transformer);
            cache.set(transformer, matcher);
            acc[type] = matcher;
            return acc;
        }, {});
    }
};
/* EXPORT */
exports.default = Utils;
