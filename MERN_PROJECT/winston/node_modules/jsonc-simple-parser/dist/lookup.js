"use strict";
/* IMPORT */
Object.defineProperty(exports, "__esModule", { value: true });
const detokenize_1 = require("./detokenize");
const parse_1 = require("./parse");
const tokenize_1 = require("./tokenize");
const utils_1 = require("./utils");
/* LOOKUP */
//FIXME: This is wonky, it should be much more robust, it should probably be rewritten from scratch
const getLookupToken = (ast, position) => {
    let tokenPosition = null, offsetCurrent = 0;
    const checkPositionToken = (token) => {
        if (token.start > position)
            return;
        if (token.end <= (position - 1))
            return;
        if (tokenPosition && utils_1.default.isTokenLiteral(tokenPosition))
            return;
        if (tokenPosition && utils_1.default.isTokenIgnored(token))
            return;
        tokenPosition = token;
    };
    const parseChild = (token, parent, depth, index) => {
        const { type, source } = token;
        const start = offsetCurrent;
        const end = (offsetCurrent += source.length);
        const ltoken = { type, source, token, parent, depth, index, start, end };
        checkPositionToken(ltoken);
        return ltoken;
    };
    const parseParent = (token, parent, depth, index) => {
        const { type } = token;
        const ltoken = { type, children: [], token, parent, depth, index };
        ltoken.children = token.children.map((child, index) => parseToken(child, ltoken, depth + 1, index)).filter(utils_1.default.isTokenLiteral);
        ltoken.children.forEach((token, index) => token.index = index);
        return ltoken;
    };
    const parseToken = (token, parent, depth, index) => {
        if ('children' in token)
            return parseParent(token, parent, depth, index);
        return parseChild(token, parent, depth, index);
    };
    parseToken(ast, null, -1, -1);
    return tokenPosition;
};
const getLookupPath = (token) => {
    if (!token)
        return [];
    const path = [];
    while (token) {
        const parent = token.parent;
        if (!parent)
            break;
        if (utils_1.default.isTokenLiteral(token)) {
            if (parent.type === 'Object') {
                if (utils_1.default.isEven(token.index)) {
                    path.unshift(JSON.parse(token.source));
                }
                else {
                    path.unshift(JSON.parse(parent.children[token.index - 1].source));
                }
            }
            else if (parent.type === 'Array') {
                path.unshift(token.index);
            }
        }
        token = parent;
    }
    return path;
};
const getLookupIsInsideProperty = (token) => {
    var _a, _b, _c, _d, _e;
    if (!token)
        return false;
    const parentType = (_a = token.parent) === null || _a === void 0 ? void 0 : _a.type;
    if (parentType === 'Object')
        return utils_1.default.isTokenLiteral(token) ? utils_1.default.isEven(token.index) : ((_c = (_b = token.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.type) === 'Array';
    if (parentType === 'Array')
        return utils_1.default.isTokenLiteral(token) || ((_e = (_d = token.parent) === null || _d === void 0 ? void 0 : _d.parent) === null || _e === void 0 ? void 0 : _e.type) === 'Array';
    return false;
};
const getLookupIsInsideValue = (token) => {
    var _a, _b;
    if (!token)
        return false;
    const isParentEmpty = !((_a = token.parent) === null || _a === void 0 ? void 0 : _a.children.length), parentType = (_b = token.parent) === null || _b === void 0 ? void 0 : _b.type;
    if (parentType === 'Object')
        return isParentEmpty || utils_1.default.isTokenDelimiter(token) || (utils_1.default.isTokenLiteral(token) && utils_1.default.isOdd(token.index));
    if (parentType === 'Array')
        return (token.depth > 1);
    return false;
};
const getLookupProperty = (token, isInsideProperty) => {
    var _a, _b;
    if (!isInsideProperty || !token)
        return;
    const parentType = (_a = token.parent) === null || _a === void 0 ? void 0 : _a.type;
    if (utils_1.default.isTokenLiteral(token)) {
        if (parentType === 'Array')
            return token.index;
        return (0, parse_1.default)((0, detokenize_1.default)(token));
    }
    else {
        if (parentType === 'Array')
            return (_b = token.parent) === null || _b === void 0 ? void 0 : _b.index;
    }
};
const getLookupValue = (token, isInsideValue, usePartialScanning) => {
    if (!isInsideValue || !token)
        return;
    if (utils_1.default.isTokenLiteral(token))
        return (0, parse_1.default)((0, detokenize_1.default)(token));
    if (usePartialScanning)
        return;
    const { parent } = token;
    if (!parent || !parent.token)
        return;
    if (parent.type !== 'Array' && parent.type !== 'Object')
        return;
    return (0, parse_1.default)((0, detokenize_1.default)(parent.token));
};
const lookup = (text, position, usePartialScanning = true) => {
    const limit = usePartialScanning ? position : Infinity, ast = (0, tokenize_1.default)(text, limit), token = getLookupToken(ast, position), path = getLookupPath(token), isInsideProperty = getLookupIsInsideProperty(token), isInsideValue = getLookupIsInsideValue(token), property = getLookupProperty(token, isInsideProperty), value = getLookupValue(token, isInsideValue, usePartialScanning), t = token ? { type: token.type, start: token.start, end: token.end, source: token.source } : undefined, result = { path, property, value, token: t, isInsideProperty, isInsideValue };
    return result;
};
/* EXPORT */
exports.default = lookup;
