"use strict";
/* IMPORT */
const isPrimitive = require("is-primitive");
const path_prop_1 = require("path-prop");
const plain_object_clone_1 = require("plain-object-clone");
const plain_object_is_equal_1 = require("plain-object-is-equal");
const plain_object_merge_1 = require("plain-object-merge");
const config_1 = require("./config");
const memory_1 = require("./providers/memory");
const type_1 = require("./utils/type");
/* CONFIGURATION */
class Configuration {
    /* CONSTRUCTOR */
    constructor(options) {
        var _a, _b;
        if (!((_a = options.providers) === null || _a === void 0 ? void 0 : _a.length))
            throw new Error('You need to pass at least one configuration provider');
        this.providers = options.providers;
        this.scopes = {};
        this.scope = (_b = options.scope) !== null && _b !== void 0 ? _b : this.providers[this.providers.length - 1].scope;
        this.handlers = [];
        this.isArray = type_1.default.isArray(options.defaults);
        this.defaults = new memory_1.default({ scope: config_1.SCOPE_DEFAULTS });
        this.defaults.writeSync(options.defaults || {}, true);
        this.schema = options.schema;
        this.filtererRaw = options.filterer;
        this.filterer = value => this.filtererRaw(value, this.schema);
        this.init();
    }
    /* HELPERS */
    _getTargetScopeForPath(path) {
        for (let i = 0, l = this.providers.length - 1; i < l; i++) {
            const { scope } = this.providers[i];
            if (this.has(scope, path))
                return scope;
        }
        return this.scope;
    }
    /* API */
    init() {
        this.providers.push(this.defaults);
        for (let i = 0, l = this.providers.length; i < l; i++) {
            const provider = this.providers[i];
            provider.filterer = this.filterer;
            provider.dataSchema = provider.filterer(provider.data);
            provider.onChange(this.refresh.bind(this));
            this.scopes[provider.scope] = provider;
        }
        this.refresh();
    }
    dispose() {
        for (let i = 0, l = this.providers.length; i < l; i++) {
            const provider = this.providers[i];
            provider.dispose();
        }
    }
    extend(namespace, data) {
        if (this.has(namespace))
            throw new Error(`The namespace "${namespace}" is already in use`);
        if (this.schema && !data.schema)
            throw new Error(`You need to provide a schema for the "${namespace}" namespace`);
        if (data.schema)
            throw new Error(`The provided schema for the "${namespace}" namespace is invalid`); //TODO: Actually validate schema
        if (!data.defaults && !data.schema)
            return () => { };
        let namespaceSchema = '';
        if (this.schema && data.schema) {
            let segments = namespace.split('.'), schemaPatch = {};
            for (let i = 0, l = segments.length - 1; i < l; i++) {
                namespaceSchema += `${i ? '.' : ''}properties.${segments[i]}`;
                const typePrev = path_prop_1.default.get(this.schema, `${namespaceSchema}.type`);
                if (typePrev && typePrev !== 'object')
                    throw new Error(`The provided schema for the "${namespace}" is incompatible with the existing schema`);
                schemaPatch = path_prop_1.default.set(schemaPatch, namespaceSchema, { type: 'object', properties: {} });
            }
            namespaceSchema += `${namespaceSchema ? '.' : ''}properties.${segments[segments.length - 1]}`;
            schemaPatch = path_prop_1.default.set(schemaPatch, namespaceSchema, data.schema);
            const schema = plain_object_merge_1.default([this.schema, schemaPatch]);
            this.schema = schema;
        }
        if (data.defaults) {
            this.defaults.writeSync(path_prop_1.default.set(this.defaults.data, namespace, path_prop_1.default.unflat(data.defaults)), true);
        }
        return () => {
            if (this.schema && data.schema) {
                path_prop_1.default.delete(this.schema, namespaceSchema);
            }
            if (data.defaults) {
                path_prop_1.default.delete(this.defaults.data, namespace);
                this.defaults.writeSync(this.defaults.data, true);
            }
        };
    }
    refresh() {
        const datas = this.providers.map(provider => provider.dataSchema).reverse(), datasFiltered = datas.filter(data => type_1.default.isArray(data) === this.isArray);
        this.dataSchema = this.isArray ? Array.prototype.concat(...datasFiltered) : plain_object_merge_1.default(datasFiltered);
        this.triggerChange();
    }
    get(scope, path) {
        if (type_1.default.isUndefined(scope))
            return this.dataSchema;
        if (scope === config_1.SCOPE_ALL) { // All
            const accumulator = {};
            for (let scope in this.scopes) {
                accumulator[scope] = type_1.default.isUndefined(path) ? this.scopes[scope].dataSchema : path_prop_1.default.get(this.scopes[scope].dataSchema, path);
            }
            return accumulator;
        }
        else if (type_1.default.isUndefined(path)) { // Path
            return path_prop_1.default.get(this.dataSchema, scope);
        }
        else { // Scope + Path
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You can\'t get from unknown scopes');
            return path_prop_1.default.get(provider.dataSchema, path);
        }
    }
    has(scope, path) {
        if (scope === config_1.SCOPE_ALL) { // All
            const accumulator = {};
            for (let scope in this.scopes) {
                accumulator[scope] = type_1.default.isUndefined(path) ? !!this.scopes[scope].dataSchema : path_prop_1.default.has(this.scopes[scope].dataSchema, path);
            }
            return accumulator;
        }
        else if (type_1.default.isUndefined(path)) { // Path
            return path_prop_1.default.has(this.dataSchema, scope);
        }
        else { // Scope + Path
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You can\'t check unknown scopes');
            return path_prop_1.default.has(provider.dataSchema, path);
        }
    }
    set(scope, path, value) {
        if (type_1.default.isUndefined(value))
            return this.set(this._getTargetScopeForPath(scope), scope, path); // Path
        if (!type_1.default.isString(path))
            return; //TSC
        if (scope === config_1.SCOPE_ALL) { // All
            for (let scope in this.scopes) {
                if (scope === config_1.SCOPE_DEFAULTS)
                    continue;
                const provider = this.scopes[scope];
                if (path_prop_1.default.get(provider.data, path) === value)
                    continue;
                path_prop_1.default.set(provider.data, path, value);
                provider.write(provider.data, true);
            }
        }
        else { // Scope + Path
            if (scope === config_1.SCOPE_DEFAULTS)
                throw new Error('You can\'t set in the "defaults" scope');
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You can\'t set in unknown scopes');
            if (path_prop_1.default.get(provider.data, path) === value)
                return;
            path_prop_1.default.set(provider.data, path, value);
            provider.write(provider.data, true);
        }
    }
    remove(scope, path) {
        if (type_1.default.isUndefined(path))
            return this.remove(config_1.SCOPE_ALL, scope); // Path
        if (scope === config_1.SCOPE_ALL) { // All
            for (let scope in this.scopes) {
                if (scope === config_1.SCOPE_DEFAULTS)
                    continue;
                const provider = this.scopes[scope];
                if (!path_prop_1.default.has(provider.data, path))
                    continue;
                path_prop_1.default.delete(provider.data, path);
                provider.write(provider.data, true);
            }
        }
        else { // Scope + Path
            if (scope === config_1.SCOPE_DEFAULTS)
                throw new Error('You can\'t delete in the "defaults" scope');
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You can\'t remove from unknown scopes');
            if (!path_prop_1.default.has(provider.data, path))
                return;
            path_prop_1.default.delete(provider.data, path);
            provider.write(provider.data, true);
        }
    }
    update(scope, data) {
        if (type_1.default.isUndefined(data))
            return this.update(this.scope, scope); // Data
        if (!type_1.default.isString(scope))
            return; //TSC
        if (scope === config_1.SCOPE_ALL) { // All
            for (let scope in this.scopes) {
                if (scope === config_1.SCOPE_DEFAULTS)
                    continue;
                this.scopes[scope].write(data);
            }
        }
        else { // Scope + Path
            if (scope === config_1.SCOPE_DEFAULTS)
                throw new Error('You can\'t update in the "defaults" scope');
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You can\'t update unknown scopes');
            provider.write(data);
        }
    }
    reset(scope = config_1.SCOPE_ALL) {
        if (scope === config_1.SCOPE_ALL) { // All
            for (let scope in this.scopes) {
                if (scope === config_1.SCOPE_DEFAULTS)
                    continue;
                this.scopes[scope].write(this.scopes[scope].defaultsRaw);
            }
        }
        else { // Scope
            if (scope === config_1.SCOPE_DEFAULTS)
                throw new Error('You can\'t reset the "defaults" scope');
            const provider = this.scopes[scope];
            if (!provider)
                throw new Error('You can\'t reset unknown scopes');
            provider.write(provider.defaultsRaw);
        }
    }
    triggerChange() {
        for (let i = 0, l = this.handlers.length; i < l; i++) {
            const data = this.handlers[i], value = data.getter();
            if (plain_object_is_equal_1.default(data.value, value))
                continue;
            const clone = isPrimitive(value) ? value : plain_object_clone_1.default(value);
            data.callback(clone, data.value);
            data.value = clone;
        }
    }
    onChange(scope, path, handler) {
        const { handlers } = this, args = arguments, getterArgs = Array.prototype.slice.call(args, 0, -1), callback = args[args.length - 1], getter = () => this.get.apply(this, getterArgs), valueRaw = getter(), value = isPrimitive(valueRaw) ? valueRaw : plain_object_clone_1.default(valueRaw), data = { callback, getter, value };
        handlers[handlers.length] = data;
        return () => {
            handlers.splice(handlers.indexOf(data), 1);
        };
    }
}
/* EXPORT */
module.exports = Configuration;
module.exports.default = Configuration;
Object.defineProperty(module.exports, "__esModule", { value: true });
